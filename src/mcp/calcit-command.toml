description = "Starting programming a feature with Calcit MCP"
prompt = """
用户指定的任务是: {{args}} .

现在开始连接到 Calcit MCP 服务进行 Calcit 程序的编程, 注意使用 Calcit 提供的结构化/原子化的操作进行代码的更新.
当前目录可能有 `compact.cirru` `calcit.cirru` 这两个文件, 但是正常情况应该不需要主动读取. 两个文件都不允许直接修改.

Calcit 程序目前有两个常用命令:

- `cr` 命令用于代码解释执行和 js 代码生成. 默认情况会读取 config 执行 init-fn 定义的入口. 一般习惯上用 `main!` 函数名表示入口. 一般方便调试用 `cr -1` 快速退出而不是监听文件.
- `caps` 命令用于安装依赖, 以及更新依赖.

可以使用 `--help` 参数了解更详细的用法. 目前没有 `calcit` 命令, 都是用的 `cr` 命令.

关于 Calcit 语言本身的功能, 可以从 MCP 服务中通过
- `query_calcit_reference` 工具读取语言文档, 了解常见功能和用法
- `query_calcit_apis` 查询语言内置的 API 以及示例

遇到代码不确定的时候, 可以使用 `cr eval 'println "|demo snippet"' 这样方式先执行一段缩进的代码先验证写法.

比较容易犯的错误可能是,
- Calcit 中字符串是通过前缀区分的, `|` 跟 `"` 这两个字符开头表示字符串, 但注意, Calcit 字符串有隐形的双引号包裹, 所以实际对应 `"|"` 和 `"\""`. `|x` 对应 JavaScript 字符串 `"x"`.
- Calcit 采用一种叫做 Cirru 的缩进语法结构,  Cirru 语法可以简单理解成去掉了跨行括号改用缩进的 Lisp 变种. Cirru 语法可以跟 Array 和 String 递归形成的语法树互相转化, 可以用 `calcit_format_json_to_cirru` 和 `calcit_parse_cirru_to_json` 相互转化结构进行试验.
- Calcit 跟 Clojure 在语义上比较像, 但是 Calcit 语法层面只用圆括号, 不用方括号花括号. 另外也有不少差异可以参阅文档.

目前 Calcit 模块约定每个模块可能存在 `docs/` 目录存放 Markdown 格式的文档, 方便 MCP 查询, 使用 `read_dependency_module_doc` 工具. 模块本身在函数定义上也有文档, 用 `read_dependency_definition_doc` 查阅.

生成复杂代码时倾向于 `update_definition_at` 搭配 `read_definition_at` 定位到分支上做局部更新, 简单情况或者兜底场景再用 `overwrite_definition`.

输出日志参考用户的输入的语种, Chinese or English is preferred.

### 补充一些 MCP 修改代码的例子

简单的直接按照参数填就好. 这几个涉及到代码提交的写法, 注意 code 实际用 JSON Array/String 怎样递归表达.


- `add_definition`

提交新的函数定义

```json
{
  "namespace": "app.core",
  "definition": "multiply",
  "code": ["fn", ["x", "y"], ["*", "x", "y"]]
}
```

- `read_definition_at` - 读取函数定义中特定位置的内容

```json
{
  "namespace": "app.core",
  "definition": "add-numbers",
  "coord": [2, 1]
}
```

注意 coord(坐标)是数组, 表示函数定义中的位置, 从 0 开始计数. 空数组表示读取整个定义.

- `update_definition_at` - 精确更新函数体中的操作符

替换的目标位置要求为表达式(array)的例子, match 可能也是一个数组节点(也可能不是):

```json
{
  "namespace": "app.core",
  "definition": "add-numbers",
  "coord": [2, 0],
  "mode": "replace",
  "match": ["+", "a", "..."],
  "new_value": ["*", "a", "b", "c"]
}
```

注意:
- `new_value` 现在必须始终是数组格式，即使是单个值也要用数组包装，如 ["my-value"]。
- `match` 这个冗余参数是用来校验位置避免失误的, 一般只给一到两层的开头, 后面其他都用 `"..."` 省略对比

替换之前建议用 `read_definition_at` 反复查看目标 coord 或者兄弟位置, 从而保证局部修改的准确度.

- `update_definition_at_with_leaf` - 精确更新函数体中的叶子节点(简化版)

专门用于替换叶子节点(符号、字符串、数字)的简化工具，无需指定 value_type 参数:

```json
{
  "namespace": "app.core",
  "definition": "add-numbers",
  "coord": [2, 0],
  "mode": "replace",
  "match": "+",
  "new_value": "*"
}
```

这个工具消除了 value_type 参数的困惑，专门处理叶子节点的替换操作。对于复杂表达式的替换，仍需使用通用的 `update_definition_at` 工具。

- `overwrite_definition`

完全重写函数定义, 注意这个操作会直接替换整个函数定义, 不会做局部修改. 建议对小的函数/定义使用, 或者兜底使用. 一般建议先确定准确坐标再通过 `update_definition_at` 做局部操作.

```json
{
  "namespace": "app.core",
  "definition": "add-numbers",
  "code": [
    "fn",
    ["a", "b"],
    ["*", "a", "b"]
  ]
}
```

- `update_namespace_imports`

更新(覆盖式)引用命名空间的定义

```json
{
  "namespace": "app.main",
  "imports": [
    ["app.lib", ":as", "lib"],
    ["app.util", ":refer", ["helper", "format-data"]],
    ["app.config", ":default", "config"]
  ]
}
```

"""
