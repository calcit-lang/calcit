description = "Starting programming a feature with Calcit MCP"
prompt = """
用户指定的任务是: {{args}} .

现在开始连接到 Calcit MCP 服务进行 Calcit 程序的编程, 注意使用 Calcit 提供的结构化/原子化的操作进行代码的更新.
当前目录可能有 `compact.cirru` `calcit.cirru` 这两个文件, 但是正常情况应该不需要主动读取. 两个文件都不允许直接修改.

由于 Calcit 脚本语言的知识不在模型内部, 要求先从 MCP 提供的文档当中了解语言功能(`query_calcit_reference`), 以及访问依赖模块的文档(`read_namespace`)了解框架或者类库, 了解相关的案例再来进行任务.

Calcit 程序目前有两个常用命令:

- `cr` 命令用于代码解释执行和 js 代码生成. 默认情况会读取 config 执行 init-fn 定义的入口. 一般习惯上用 `main!` 函数名表示入口.
- `caps` 命令用于安装依赖, 以及更新依赖.

可以使用 `--help` 参数了解更详细的用法. 目前没有 `calcit` 命令, 都是用的 `cr` 命令.

关于 Calcit 语言本身的功能, 可以从 MCP 服务中通过
- `query_calcit_reference` 工具读取语言文档, 了解常见功能和用法
- `query_calcit_apis` 查询语言内置的 API 以及示例

遇到代码不确定的时候, 可以使用 `cr eval 'println "|demo snippet"' 这样方式先执行一段缩进的代码先验证写法.

比较容易犯的错误可能是,
- Calcit 中字符串是通过前缀区分的, `|` 跟 `"` 这两个字符开头表示字符串, 但注意, Calcit 字符串有隐形的双引号包裹, 所以实际对应 `"|"` 和 `"\""`. `|x` 对应 JavaScript 字符串 `"x"`. 另外产生 JSON 时候, 字符串注意不要重复包裹.
- Calcit 采用一种叫做 Cirru 的缩进语法结构,  Cirru 语法可以简单理解成去掉了跨行括号改用缩进的 Lisp 变种. Cirru 语法可以跟 Array 和 String 递归形成的语法树互相转化, 可以用 `calcit_format_json_to_cirru` 和 `calcit_parse_cirru_to_json` 相互转化结构进行试验.
- Calcit 跟 Clojure 在语义上比较像, 但是 Calcit 语法层面只用圆括号, 不用方括号花括号. 另外也有不少差异可以参阅文档.

目前 Calcit 模块约定每个模块可能存在 `docs/` 目录存放 Markdown 格式的文档, 方便 MCP 查询, 使用 `read_dependency_module_doc` 工具. 模块本身在函数定义上也有文档, 用 `read_dependency_definition_doc` 查阅.

生成复杂代码时倾向于 `operate_definition_at` 搭配 `read_definition_at` 定位到分支上做局部更新, 简单情况或者兜底场景再用 `upsert_definition`.

输出日志参考用户的输入的语种, Chinese or English is preferred.

### 补充一些 MCP 修改代码的例子

Calcit 这个结构很大程度上是为了结构化编辑语法树设计的, 所以大量使用 JSON(Array/String 形成递归嵌套, Number 等也要表示为 String), 而且这个 JSON 结构跟 Cirru 这套缩进的语法可以相互转化.
编码过程当中简单的直接按照参数填就好. 这几个涉及到代码提交的写法, 注意 code 实际用 JSON Array/String 怎样递归表达.


- `upsert_definition`

创建新的函数定义或完全重写现有定义。这个统一工具结合了 add_definition 和 overwrite_definition 的功能。

创建新定义 (replacing=false):
```json
{
  "namespace": "app.core",
  "definition": "multiply",
  "replacing": false,
  "syntax_tree": ["fn", ["x", "y"], ["*", "x", "y"]]
}
```

重写现有定义 (replacing=true):
```json
{
  "namespace": "app.core",
  "definition": "multiply",
  "replacing": true,
  "syntax_tree": ["fn", ["x", "y"], ["+", "x", "y"]]
}
```

- `read_definition_at` - 读取函数定义中特定位置的内容

```json
{
  "namespace": "app.core",
  "definition": "add-numbers",
  "coord": [2, 1]
}
```

注意 coord(坐标)是数组, 表示函数定义中的位置, 从 0 开始计数. 空数组表示读取整个定义.

- `operate_definition_at` - 精确更新函数体中的操作符

替换的目标位置要求为表达式(array)的例子, match 可能也是一个数组节点(也可能不是):

```json
{
  "namespace": "app.core",
  "definition": "add-numbers",
  "coord": [2, 0],
  "mode": "replace",
  "shallow_check": ["+", "a", "..."],
  "new_value": ["*", "a", "b", "c"]
}
```

注意:
- `new_value` 现在必须始终是数组格式，即使是单个值也要用数组包装，如 ["my-value"]。
- `match` 这个冗余参数是用来校验位置避免失误的, 一般只给开头的一些内容, 后面其他都用 `"..."` 表示工具执行过程中不在需要对比

替换之前建议用 `read_definition_at` 反复查看目标 coord 或者兄弟位置, 从而保证局部修改的准确度.

- `operate_definition_at_with_leaf` - 精确更新函数体中的叶子节点(简化版)

专门用于替换叶子节点(符号、字符串、数字)的简化工具，无需指定 value_type 参数:

```json
{
  "namespace": "app.core",
  "definition": "add-numbers",
  "coord": [2, 0],
  "mode": "replace",
  "shallow_check": "+",
  "new_value": "*"
}
```

这个工具消除了 value_type 参数的困惑，专门处理叶子节点的替换操作。对于复杂表达式的替换，仍需使用通用的 `operate_definition_at` 工具。

注意这里的 `syntax_tree` 写法, 是以递归数组的形式传递的. 对于现有定义的修改, 一般建议先确定准确坐标再通过 `operate_definition_at` 做局部操作, 而不是完全重写整个定义.

- `update_namespace_imports`

更新(覆盖式)引用命名空间的定义

```json
{
  "namespace": "app.main",
  "imports": [
    ["app.lib", ":as", "lib"],
    ["app.util", ":refer", ["helper", "format-data"]],
    ["app.config", ":default", "config"]
  ]
}
```

另外排查问题时可以多沿着 namespace 查看定义, 查看定义上文档, 设置模块当中的命名空间定义和文档等等.

### 开发调试

特别简单的脚本可以用 `cr -1 <filepath>` 直接执行, 但复杂有状态的程序还是用需要用 MCP 工具打开. 另外如果是编译 JavaScript 那么用 `cr -1 <filepath> js` 可以执行一次编译.

调试模式, Calcit snapshot 文件中 config 有两个配置 `init-fn` 和 `reload-fn`, 初次启动时会调用 `init-fn`, 后续每次修改代码会调用 `reload-fn`.
为了适配这个用法, Calcit 提供了几个 MCP 工具

- `start_calcit_runner`

会对程序做一些处理, 然后后台启动一个程序实例, 并搜集日志. 这里使用 `cr <filepath>` 或者 `cr <filepath> js` 启动, 不会马上退出, 会等待增量文件更新.

初次启动后稍等一秒也从日志确认程序是否正常运行.

- `generate_calcit_incremental`

一个功能修改完毕(可能是多次修改以后), 用这个工具生成增量文件. Calcit 监听到变更以后会触发程序的 reload.

开发网页时, 建议少量样式修改就通过 `generate_calcit_incremental` 生成增量文件, 从而触发 js 编译方便快速调试.

- `grab_calcit_runner_logs`

提取日志用于解读. 提取后下次在提取不会包含前一次的地址. 这个主要在 reload 发生产以后使用.

确保修改过后先运行 `generate_calcit_incremental` 然后再查看日志.

- `stop_calcit_runner`

获取剩下的日志, 然后关闭程序实例.

### 文档支持

Calcit 脚本语言是走小众路线的快速开发工具, 且作为 Lisp 方言过于灵活和自定义, 所以文档支持不是很完善. 出现疑问和不确定的时候使用:

- `query_calcit_reference` 查询 Calcit 分章节教程当中的内容,
- `query_calcit_apis` 查询 API 文档当中语言核心功能的使用示例,
- `read_namespace` 查看命名空间当中的说明以及函数定义函数文档,
- `read_definition_doc` 指定的命名空间下某一个定义的文档,
- `read_definition_at` 查看语法树.

如果有文档缺失或者查找的链路不通, 请明确在日志当中说明, 会有专门的 Agent 收集问题寻找解决方案, 或者由工程师手动补充文档.

### 记忆管理和反馈工具

Calcit MCP 服务提供了记忆管理和反馈功能，帮助保存和检索开发过程中的重要信息：

- `list_calcit_work_memory` - 列出所有保存的记忆条目

```json
{}
```

返回所有记忆条目的名称和编码列表。

- `read_calcit_work_memory` - 读取指定的记忆内容

按编码读取：
```json
{
  "memory_id": "mem_001"
}
```

按关键词搜索：
```json
{
  "search_keyword": "函数定义"
}
```

- `write_calcit_work_memory` - 保存记忆条目

```json
{
  "memory_name": "重要的函数实现",
  "content": "这里记录了关键的函数实现方法和注意事项",
  "overwrite": false
}
```

- `feedback_to_calcit_mcp_server` - 向服务器发送反馈

```json
{
  "feedback_content": "发现了一个性能优化的机会",
  "feedback_type": "suggestion"
}
```

记忆文件保存在 `~/.calcit/work_memory/` 目录下，反馈文件保存在 `~/.calcit/feedback/` 目录下。这些工具有助于在开发过程中保存重要的发现、解决方案和改进建议。

"""
